# Software Engineering

## Table of Contents

   - [Introduction](#Introduction)
      - [The Evolution of Software Engineering Best Practices and Emerging Trends](#The-Evolution-of-Software-Engineering-Best-Practices-and-Emerging-Trends)
      - [Features of Contemporary Software Engineering](#Features-of-Contemporary-Software-Engineering)
      - [Software Engineering Development Techniques](#Software-Engineering-Development-Techniques)
      - [Various System Modeling Fundamentals](#Various-System-Modeling-Fundamentals)
      - [System Modeling and Object-Oriented Software](#System-Modeling-and-Object-Oriented-Software)
      - [Software Testing Plans](#Software-Testing-Plans)
      - [Software Engineering Applied to Real Life](#Software-Engineering-Applied-to-Real-Life)
   
   - [Software Engineering](#Software-Engineering)
      - [Key Elements of Software Engineering](#Key-Elements-of-Software-Engineering)
      - [Applicable Software Engineering Methodologies](#Applicable-Software-Engineering-Methodologies)
      - [The Fundamentals of Software Engineering](#The-Fundamentals-of-Software-Engineering)
      - [Software Process Models](#Software-Process-Models)
   
   - [Software Development and Requirements Engineering](#Software-Development-and-Requirements-Engineering)
      - [Scrum, Agile Development Techniques and Scaling](#Scrum,-Agile-Development-Techniques-and-Scaling)
      - [User and System Requirements](#User-and-System-Requirements)
      - [Functional and Non-Functional Requirements](#Functional-and-Non-Functional-Requirements)
      - [Main Activities for Requirements Engineering](#Main-Activities-for-Requirements-Engineering)
      
   - [ Modeling and Architectural Design](#System-Modeling-and-Architectural-Design)
      - [Differences Between Applying Different System Models](#Differences-Between-Applying-Different-System-Models)
      - [The Model View Controller](#The-Model-View-Controller)
      - [5 Unified Modeling Languages ](#5-Unified-Modeling-Languages )
      - [Behavioral Modeling](#Behavioral-Modeling)
      - [Generic Models of Application Systems](#Generic-Models-of-Application-Systems)
      
   - [Software Design, Implementation, and Testing](#Software-Design,-Implementation,-and-Testing)
      - [Software Reuse](#Software-Reuse)
      - [The Fundamental Configuration Management Activities](#The-Fundamental-Configuration-Management-Activities)
      - [Host-Target Development Platform](#Host-TargetDevelopment-Platform)
      - [Open-Source Development](#Open-Source-Development)
      - [Software Inspection](#Software-Inspection)
      - [Development and User Testing](#Development-and-User-Testing)
      
   - [Software Evolution and Maintenance](#Software-Evolution-and-Maintenance)
      - [Four Clusters of N Systems](#Four-Clusters-of-N-Systems)
      - [Types of Software Maintenance](#Types-of-Software-Maintenance)
      - [Reengineering of the Software Process](#Reengineering-of-the-Software-Process)
      
      
      
      
      
## Introduction

### The Evolution of Software Engineering: Best Practices and Emerging Trends
This paper is about contemporary software engineering and its key features. It covers software development, software engineering, software process, process models, and system modeling fundamentals. It also touches on software engineering development techniques such as Agile methodology, plan-driven methodology, and requirements engineering. System modeling is an important aspect of software engineering and object-oriented software development. It helps define the structure, behavior, and interactions of a software system and its components. The architectural design of a software system is defined using system modeling and it is used to guide the implementation of the software system. The paper concludes that system modeling basics help create well-designed, scalable, and maintainable software systems by improving our understanding of the software system.

![SoftwareEngineeringConceptMap-week1 drawio](https://user-images.githubusercontent.com/79364739/216880063-3cf4f120-d18c-454b-966f-b97925f65386.png)

### Features of Contemporary Software Engineering
Contemporary Software Engineering encompasses several key features. Software Development which includes the development of software systems using various methodologies, tools, and techniques. Software Engineering which is the application of engineering principles to the design, development, and maintenance of software systems. Software Process which refers to the set of activities involved in creating a software system, including requirements analysis, design, implementation, testing, and maintenance. Process Models which is a framework that provides guidelines and standards for software development, such as Agile, Waterfall, Spiral, and others.

Process Activities where there are the individual steps involved, including planning, design, coding, testing, and deployment. Software Design and Implementation that includes the creation of a detailed plan for software development, including the use of design patterns, data structures, and algorithms to implement software systems. Software Validation which refers to the process of ensuring that software meets its specified requirements and is fit for its intended use. This involves activities such as testing, inspection, and verification. Software evolution refers to the process of changing and updating software systems over time to address changing requirements and technology. This includes activities such as maintenance, refactoring, and updating.

### Software Engineering Development Techniques
Software engineering is the process of designing, building, and maintaining software systems. There are different approaches and methodologies used in software development, including:

Agile methodology: An iterative and adaptive approach to software development that emphasizes collaboration, flexibility, and customer satisfaction. The Agile process is often divided into sprints, during which a small, cross-functional team develops and delivers a functional portion of the software.

Plan-driven methodology: A traditional, sequential approach to software development that follows a set of strict plans and specifications. The process is typically divided into distinct phases, including requirements gathering, design, implementation, testing, and deployment.

Requirements engineering: The process of eliciting, analyzing, and documenting the requirements of a software system. This includes defining the problem to be solved, identifying the stakeholders, and determining the functional and non-functional requirements.

Specifications: Detailed description of how a software system is expected to behave and perform. Specifications can include functional requirements, performance requirements, and design constraints.

Use cases: A description of how a software system will be used to solve a particular problem for a specific user. Use cases are often used to define requirements and to help design the software.

Validations: The process of checking that a software system meets the specified requirements and works as intended. This includes both functional and non-functional testing, such as unit testing, integration testing, and acceptance testing.

Change management: The process of managing changes to a software system, including changes to requirements, design, and code. Change management involves documenting and tracking changes, assessing the impact of changes, and controlling the release of new software versions.

### Various System Modeling Fundamentals
System modeling is an important aspect of software engineering that helps to describe and understand the behavior and structure of a software system. Context-models represent the system's operating environment as well as the interactions between the system's stakeholders. The limits of the system and the actors who interact with it can both be determined using context models. Interaction-models describe the stakeholder and system communication channels. They support the definition of the system's inputs, outputs, and user-system interactions.

The system's constituent parts, and their interactions are represented by structural models. The architecture of the system and each of its parts, including the data structures and algorithms employed, are described using structural models. The dynamic behavior of the system is described by behavioral models, along with the events that cause state changes and the responses of the system to these events. The most important interactions between the system and its stakeholders can be found using behavioral models.

These system modeling fundamentals, which include the specification of architectural perspectives, architectural patterns, and application architectures, contribute to the architectural design of a software system. The architectural views of a software system represent several perspectives, including the data perspective, the process perspective, and the interface perspective. The behavior and structure of the system can be understood from many angles with the use of architectural views. Reusable solutions to persistent architectural issues are known as architectural patterns. They offer a guide for resolving particular issues, such scalability or performance optimization. An application architecture explains the general organization and operation of a software system.

They offer a high-level overview of the system, including its elements and their connections, the data structures, and algorithms in use, as well as interactions between the system and its users. In conclusion, the numerous system modeling basics help create well-designed, scalable, and maintainable application architectures by improving our understanding of the software system.

### System Modeling and Object-Oriented Software
System modeling is an important aspect of object-oriented software development, as it helps to define the structure, behavior, and interactions of the system and its components. Object-oriented software development focuses on modeling real-world objects and their relationships, and system modeling provides a way to represent these objects and relationships in a software system. In the process of developing object-oriented software, system modeling is used to define the architectural design, including the components and their relationships, the interactions between the components, and the behavior of the system as a whole.

For example, a context model can be used to define the environment in which the software system operates and the interactions between the system and its stakeholders. An interaction model can be used to define the communication between the system and its stakeholders, and a structural model can be used to define the components of the system and their relationships. Once the architectural design has been defined, system modeling is used to guide the implementation of the software system. The structural model can be used to guide the design and implementation of the components of the system, and the interaction model can be used to guide the design and implementation of the communication between the components.

In conclusion, system modeling is a valuable tool in the development of object-oriented software, as it helps to define the architectural design and guide the implementation of the software system. By representing the structure, behavior, and interactions of the system and its components, system modeling helps to ensure that the software system is well-designed, scalable, and maintainable.

### Software Testing Plans
Software testing is an important aspect of software development, as it helps to ensure that the software is functioning as intended and meets the requirements of its stakeholders. There are various software testing plans, including:

•	Development Testing
•	Release Testing
•	User Testing

The mechanisms to control software changes or evolution processes include change management and version control. Change management is the process of controlling changes to the software, including the review and approval of changes, the tracking of changes, and the rollback of changes if necessary. Version control is the management of different versions of the software, including the tracking of changes and the ability to revert to a previous version if necessary.

Software maintenance is the process of maintaining and updating the software after its release. This includes fixing bugs, adding new features, and updating the software to meet changing requirements. Software maintenance is an ongoing process, and the software testing plan should include ongoing testing to ensure that the software remains functioning as intended. In conclusion, the software testing plan is an important aspect of software development, as it helps to ensure that the software is of high quality and meets the needs of its stakeholders. The software testing plan should include a variety of testing phases, including development testing, release testing, and user testing, as well as mechanisms to control software changes and evolution processes, and a plan for software maintenance.

### Software Engineering Applied to Real Life
The concepts of software engineering, such as system modeling, software testing plans, and software development methodologies, are fundamental skills that can be applied in many areas of the software development process. These concepts can be useful in future courses and jobs in a variety of ways:

In future courses: The concepts of software engineering can be applied in advanced software development courses, where students can build on their knowledge of these concepts and apply them to real-world software development projects.

In future jobs: The concepts of software engineering can be applied in a variety of roles within the software development industry, including software development, software testing, software architecture, and project management. By understanding the concepts of software engineering, individuals can work effectively in these roles and contribute to the development of high-quality software systems.

In conclusion, the concepts of software engineering are valuable skills that can be applied in a variety of ways in future courses and jobs. Understanding these concepts and how to apply them can help individuals to contribute to the development of high-quality software systems and be successful in a variety of roles within the software development industry.





## Software Engineering

### Key Elements of Software Engineering
Software engineering is the process of designing and building software systems using principles from other disciplines, such as management science and computer science. Despite having a sizable common area of concern, education in software engineering is fundamentally distinct from education in computer science, management science, or other constituent subjects. It is imperative that we define concepts, not merely haphazard collections of techniques, on which to build integrated software engineering programs. We suggest that computer science, management science, communication skills, problem solving, and design methodology should be included in any software engineering curriculum. This is based on our research, teaching, and real-world experience.

### Applicable Software Engineering Methodologies
When implementing new features, teams employ the agile development technique to reduce risk. Teams create software in iterations that include tiny increments of new functionality according to all agile development methodologies. The agile development methodology comes in a variety of forms, including as scrum, crystal, extreme programming (XP), and feature-driven development.

![3-SoftwareProcesses](https://user-images.githubusercontent.com/79364739/216875404-5d30fce3-794b-4857-99b3-d2409e07a85c.jpg)

### The Fundamentals of Software Engineering
A software process, sometimes referred to as a software methodology, is a collection of related tasks that result in the creation of software. These tasks could include creating new software from scratch or altering an existing one. The following four actions must be included in any software process:
Software specifications define the primary software functionality and the restrictions that apply to them in the software specification (also known as requirements engineering). Software design and implementation is Programming and design of the software are required. Software validation the software must adhere to its specification and satisfy the needs of the user. Software evolution is the software being updated to reflect changes in customer and market demands. In actuality, they comprise sub-activities like unit testing, architectural design, and requirements validation.
The waterfall method separates the process activities of requirements specification, software design, development, validation, and testing into separate process phases. The strategy known as the incremental development method interleaves the processes of specification, development, and validation. The system is created in a series of versions, each of which includes functionality that was not present in the prior iteration. The procedure that depends on the availability of reusable systems or components is integration and configuration. The system development process focuses on setting up and integrating this component for use in a new environment.

### Software Process Models
The process of gathering stakeholder wants and wishes and turning them into an accepted set of specific requirements that can be the foundation for all ensuing development operations is known as requirements engineering. Making the problem that is being expressed clear and comprehensive and ensuring that the solution is accurate, reasonable, and efficient are the two goals of requirements engineering approaches. This chapter lists the representative requirements engineering approaches that are currently in use, mostly concentrating on the fundamentals. Requirements engineering techniques are methods for transforming real-world issues into solutions for the digital world. Each approach uses a distinct process to develop the system specification as the solution, each with its own specialized way of thinking about the real-world problem.





## Software Development and Requirements Engineering

### Scrum, Agile Development Techniques and Scaling
A team completes a predetermined amount of work during a timed period called a Scrum sprint cycle. Each sprint begins as soon as the previous one is over and lasts for two to four weeks on average. The Scrum sprint cycle is frequently described as a continuous development method.

It gives product releases a predictable work cadence and maintains the project's momentum till completion which leads to extreme programming. Extreme Programming (XP) is an agile software development paradigm that seeks to deliver software of a better caliber while also improving the team's quality of life. Of the agile frameworks, XP is the most explicit in terms of the proper engineering techniques for software development.

For small and medium sized projects that can be developed by a small co-located team, agile methodologies have shown to be effective. It is occasionally asserted that the effectiveness of these techniques is due to enhanced communication, which is achievable when everyone is cooperating. Agile methodologies need to be modified in order to handle bigger, lengthier projects with various development teams that may be spread out across different regions.

### User and System Requirements
Users and system needs are not that different from one another. User requirements specify what the user is expected to do. System requirements include both functional needs such as the system should manage 100000 users at the same time and non-functional requirements that specify how the user will fulfill user requirements when engaging with the system.

User Requirements: The user's test results must be visible to them.
System Requirements: The user accesses the results page to view their test results as per the system requirement.

![4-RequirementsEngineering](https://user-images.githubusercontent.com/79364739/216875618-2a9580d8-7b76-442a-ad4e-9cc30958e92c.jpg)

### Functional and Non-Functional Requirements
Functional requirements These include expectations for the system's functionality, its responses to different inputs, and how it would need to respond in certain circumstances. The functional requirements may, in some situations, also explicitly indicate what the system should not accomplish. Requirements that are not functional These are limitations on the products or services the system has to offer. They include limitations imposed by standards, deadline restrictions, and limitations on the development process. Non-functional requirements frequently concern the entire system rather than specific features or services.

### Main Activities for Requirements Engineering
   -Elucidating Requirements
   Understanding what stakeholders do and how they could utilize a new system to support that work is the goal of the software requirements elicitation process. Software engineers collaborate with stakeholders during requirements elicitation to learn about the application domain, work activities, services, and system features that stakeholders desire, as well as the necessary system performance. hardware limitations, etc.
   
   -Specifying Requirements
   Writing down the user and system needs in a requirements document is the process known as requirements specification. The requirements for the user and the system should be distinct, straightforward, simple to comprehend, comprehensive, and consistent.
   
   -Validating Requirements
   Writing down the user and system needs in a requirements document is the process known as requirements specification. The requirements for the user and the system should be distinct, straightforward, simple to comprehend, comprehensive, and consistent.
   
   -Requirements Always Change
   New requirements always appear once a system has been implemented and is being utilized frequently. This is partially due to mistakes and omissions in the initial specifications that must be fixed. However, changes to the system's business environment are the main driver of changes in system requirements.





## System Modeling and Architectural Design

### Differences Between Applying Different System Models
Essential viewpoints in software engineering and systems design include context, interaction, structure, and behavior modeling. To comprehend and create complex systems, various models are used since each one offers a unique perspective on the system under development. Interaction modeling focuses on how components interact with one another, structure modeling offers a thorough perspective of the components, and behavior modeling captures the system's changing behavior over time. Context modeling offers a high-level view of the system's surroundings.

Context modeling offers a broad perspective of the environment surrounding the system, including outside variables that affect the system's behavior. The focus of interaction modeling is on the relationships and interactions that exist between the various system components. Structure modeling offers a thorough perspective of the system's elements, including a look at their internal organization and interrelationships. Behavior modeling offers a dynamic perspective of the system, capturing how the parts work together and behave over time in response to alterations in the outside world or the actions of other parts.

### The Model View Controller

![5-SystemModeling](https://user-images.githubusercontent.com/79364739/216875939-eab9b5f1-d1aa-485b-a12e-175c982dda5a.jpg)

### 5 Unified Modeling Languages
Software engineers utilize the Model-View-Controller (MVC) design pattern to separate the presentation of information from how the user interacts with it. There are three primary parts to the pattern:

Model: Represents the application's core data and business logic. The Business Logic Layer or the Data Access Layer would normally be the counterpart of the Model component in a layered architecture.

View: Gives the viewer a visual representation of the data. The View component would normally match the Presentation Layer in a layered architecture. The View component would normally be built on the client side in a Client-Server architecture.

Controller: As a bridge between the Model and the View, the Controller manages user input and coordinates updates to both the Model and the View. Layered Architecture is a type of

By preventing changes to one component from affecting the other components, the MVC pattern's separation of responsibilities enhances the application's maintainability, scalability, and testability. Both the View and the Controller can be updated independently of the Model component, and the Model and Controller can be updated independently of the View.

In a web-based application, for instance, the Model component might stand in for a database of products and the information related to them, the View component might represent the user interface through which the user is shown the product information, and the Controller component might manage user input, such as adding or removing products from the database.

![6-ArchitecturalDesign](https://user-images.githubusercontent.com/79364739/216875947-9fa0e3a4-df44-45ec-ae19-4f08626f5003.jpg)

### Behavioral Modeling
A method for describing how a system behaves in response to events is called behavioral modeling. While event-driven modeling concentrates on the occurrences that cause changes in the state of the system, data-driven modeling concentrates on the data that drives the behavior of the system. Both modeling approaches can be used to explain how a system behaves and, depending on the needs of the system, are suitable in certain situations. Data-driven modeling and event-driven modeling are the two basic categories of behavioral modeling (state diagram).

Data-driven modeling: In data-driven modeling, the values of the system's inputs and internal data influence how the system behaves. The model specifies a set of interactions between the system's inputs and outputs, and by resolving these relationships, the system's behavior is ascertained. The information that underlies the system's action is the focus.
Event-driven modeling (state diagram): In event-driven modeling, the occurrence of events controls the system's behavior. The model outlines the possible states for the system, as well as potential events and the resulting transitions between states. The emphasis is on the occurrences that cause changes in the system's state.

### Generic Models of Application Systems
An application system known as a transaction processing system (TPS) processes transactions, the fundamental units of work that cause a change in the state of the system. TPSs are built to ensure the integrity of the data being processed while handling massive quantities of data and numerous transactions quickly.

Language Processing System (LPS): An application system that processes and modifies language data is known as an LPS. An LPS's primary objective is to transform one language into a different way of presenting that language, such as through transcribing spoken language into writing or translating a document from one language to another.





## Software Design, Implementation, and Testing

### Software Reuse
Software reuse refers to the use of existing software components, modules, or functions in the development of new software systems. There are three main levels of software reuse. Component-level reuse, which refers to the reuse of pre-existing, low-level components such as libraries, frameworks, or tools. There’s Application-level reuse that refers to the reuse of entire pre-existing applications or modules, as a building block for new applications. Domain-level reuse which refers to the reuse of a common, abstract solution to a problem that has been derived from a particular business or technical domain.

The benefits of software reuse include increased productivity which is Reusing existing code can significantly reduce the time and effort required to develop new software. Improved quality that are reused components generally well tested, debugged, and reliable, which can lead to improved overall quality of the new software. Lastly, there are cost savings which consist of reusing existing software can help reduce development costs, as there is no need to create new code from scratch.

Example: Consider a software development company that specializes in developing e-commerce websites. The company can reuse existing code for common functionality such as shopping cart management, payment processing, and customer management, across multiple e-commerce projects, thus reducing the development time and effort for each new project.

### The Fundamental Configuration Management Activities
Configuration management (CM) is the process of identifying, organizing, and controlling changes to the software development process and the associated artifacts. The fundamental activities of CM include configuration identification, configuration control, configuration status accounting, configuration auditing, configuration baseline, and configuration change management. These activities are critical for ensuring the integrity and traceability of the software development process, and for ensuring that changes to the product are well controlled and properly documented.

### Host-Target Development Platform
A host-target development platform refers to a software development environment in which the software is developed on a host computer and then compiled and executed on a target system. The target system can be an embedded system, a single-board computer, or any other system that runs the software.

The host-target development platform provides the following essential capabilities: cross-compilation, debugging, testing, source code management, integration, and deployment. These capabilities allow the software development process to be streamlined and more efficient, by enabling the software to be developed on a more powerful host computer and tested and debugged on the target system.

![7-DesignAndImplementation](https://user-images.githubusercontent.com/79364739/216876005-f0472e41-fe57-4561-a7ad-f0a3db1db769.jpg)

### Open-Source Development
Open-source development is a model of software development in which the source code of a software product is made publicly available and can be freely used, modified, and distributed. It has become a widely adopted model for software development, and has led to the creation of many popular and widely-used software products, such as the Linux operating system, the Apache web server, and the Python programming language. Leveraging open-source development can provide many benefits, such as lower costs, access to a large pool of talent, and the ability to leverage existing solutions.

### Software Inspection
Software inspection is a quality assurance technique that involves reviewing the source code of a software program, usually by a team of peers, to identify defects and improve its quality. This technique helps to complement software testing by identifying problems early in the development process before they become more difficult and costly to fix. Software testing focuses on verifying that a software program meets its specified requirements and works as expected, whereas software inspection focuses on the design and code quality of the software. By combining both techniques, a development team can reduce the number of defects in the final product, save time and resources, and produce higher-quality software.

### Development and User Testing
Development testing is a software testing process that occurs during the software development lifecycle and is performed by developers, not just by testers. It is aimed at finding and fixing defects as early as possible, reducing the cost of fixing them, and ensuring that the final product meets the requirements and is of high quality. User testing is a type of software testing that focuses on evaluating a software program from the perspective of its intended users. It is aimed at ensuring that the software meets the needs and expectations of its target audience, and that it is user-friendly and easy to use.

![8-SoftwareTesting](https://user-images.githubusercontent.com/79364739/216876014-00ae4fa1-70cf-45dd-b258-b664ce0c955d.jpg)





## Software Evolution and Maintenance

### Four Clusters of N Systems
The four clusters of N systems based on "quality" versus "business value" coordinates can be described as follows:

High Quality, High Business Value: These systems have both high quality and high business value, meaning they deliver high value to the business and are of high quality.

Low Quality, High Business Value: These systems have high business value but low quality, meaning they deliver high value to the business but have poor technical characteristics.

High Quality, Low Business Value: These systems have high quality but low business value, meaning they have strong technical characteristics but do not deliver significant value to the business.

Low Quality, Low Business Value: These systems have low quality and low business value, meaning they have poor technical characteristics and deliver little value to the business.

### Types of Software Maintenance
Software maintenance refers to the process of modifying and updating a software system after it has been delivered to the customer. There are three main types of software maintenance:

Corrective Maintenance: This type of maintenance is performed to correct faults or bugs in a software system. It is the process of fixing errors and problems that have been detected in the software.

Adaptive Maintenance: This type of maintenance is performed to adapt the software system to changes in the operating environment. It is the process of modifying the software to work with new hardware or software systems.

Perfective Maintenance: This type of maintenance is performed to improve the functionality and performance of a software system. It is the process of adding new features, improving the user interface, and enhancing the performance of the software.

Each type of maintenance is performed for different reasons and has a different focus. The types of maintenance can overlap and may be performed in combination to ensure the continued operation and effectiveness of the software system.

![9-SoftwareEvolution](https://user-images.githubusercontent.com/79364739/216876107-675874ed-e6d9-405a-9e14-b15aee81a9f8.jpg)

### Reengineering of the Software Process
A general model for the reengineering of software process involves several phases that are used to take a legacy program as input and produce an improved version of the same program as an output. Here are the Phases:

Assessment: This phase involves analyzing the existing software system to determine its strengths and weaknesses, as well as to identify any areas that need to be improved.

Reverse Engineering: This phase involves decompiling the existing software to understand its architecture and design, as well as to identify any issues that need to be addressed.

Requirements Analysis: This phase involves identifying the requirements for the improved software system, including any new features, changes to existing features, and performance improvements.

Design: This phase involves creating a detailed design for the improved software system, including its architecture, data structures, and algorithms.

Implementation: This phase involves actually implementing the design, using a programming language, to produce the improved software system.

Testing: This phase involves testing the improved software system to ensure that it meets the requirements and works as intended.

Deployment: This phase involves deploying the improved software system to the production environment, making it available to end users.
The reengineering of software process is a complex and time-consuming process, but it can lead to significant improvements in the quality, reliability, and performance of the software system.
