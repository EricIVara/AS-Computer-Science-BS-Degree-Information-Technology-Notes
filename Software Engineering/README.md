# Software Engineering

## Table of Contents

   - [1.0 Introduction](#1.0-Introduction)
   
   - [2.0 Software Engineering](#2.0-Software-Engineering)
      - [Key Elements of Software Engineering](#Key-Elements-of-Software-Engineering)
      - [Applicable Software Engineering Methodologies](#Applicable-Software-Engineering-Methodologies)
      - [The Fundamentals of Software Engineering](#The-Fundamentals-of-Software-Engineering)
      - [Software Process Models](#Software-Process-Models)
   
   - [3.0 Software Development and Requirements Engineering](#3.0-Software-Development-and-Requirements-Engineering)
      - [Scrum, Agile Development Techniques and Scaling](#Scrum,-Agile-Development-Techniques-and-Scaling)
      - [User and System Requirements](#User-and-System-Requirements)
      - [Functional and Non-Functional Requirements](#Functional-and-Non-Functional-Requirements)
      - [Main Activities for Requirements Engineering](#Main-Activities-for-Requirements-Engineering)
      
   - [4.0 System Modeling and Architectural Design](#4.0-System-Modeling-and-Architectural-Design)
      - [Differences Between Applying Different System Models](#Differences-Between-Applying-Different-System-Models)
      - [The Model View Controller](#The-Model-View-Controller)
      - [5 Unified Modeling Languages ](#5-Unified-Modeling-Languages )
      - [Behavioral Modeling](#Behavioral-Modeling)
      - [Generic Models of Application Systems](#Generic-Models-of-Application-Systems)
      
   - [5.0 Software Design, Implementation, and Testing](#5.0-Software-Design,-Implementation,-and-Testing)
      - [Software Reuse](#Software-Reuse)
      - [The Fundamental Configuration Management Activities](#The-Fundamental-Configuration-Management-Activities)
      - [Host-Target Development Platform](#Host-TargetDevelopment-Platform)
      - [Open-Source Development](#Open-Source-Development)
      - [Software Inspection](#Software-Inspection)
      - [Development and User Testing](#Development-and-User-Testing)
      
   - [6.0 Software Evolution and Maintenance](#6.0-Software-Evolution-and-Maintenance)
      - [Four Clusters of N Systems](#Four-Clusters-of-N-Systems)
      - [Types of Software Maintenance](#Types-of-Software-Maintenance)
      - [Reengineering of the Software Process](#Reengineering-of-the-Software-Process)
      
      
      
      
      
## 1.0 Introduction

Government, society, and domestic and foreign enterprises and organizations all depend on software engineering to function. The modern world cannot function without software. Most electrical items include a computer and controlling software, and computer-based systems are used to manage national infrastructure and utilities. Both the financial system and industrial manufacture and distribution are fully automated. Software is used extensively in the entertainment sector, which includes the music business, video games, and film and television. By 2016, practically all software-controlled mobile phones will be Internet-capable, with more than 75% of the world's population having one.

Software systems are ethereal and abstract. They are not limited by the characteristics of the materials, nor are they controlled by physical principles or production procedures. Since software's potential has no inherent boundaries, this makes software engineering simpler. However, due to the lack of physical limitations, software systems can easily grow to be very complicated, challenging to comprehend, and expensive to modify.

Software systems come in a broad variety of forms, from straightforward embedded systems to intricate global information systems. Because various software types require various methodologies, there are no standard notations, procedures, or strategies for software engineering. Creating a controller for a scientific instrument is absolutely unrelated to creating an organizational information system. Both of these systems have little in common with a graphically complex video game. Even while not all of these applications use the same software engineering methodologies and processes, they still require software engineering.

Software disasters and failed software initiatives continue to be widely reported. Modern software development is criticized as not being suited for software engineering. However, in my opinion, two reasons are to blame for a large number of these alleged software failures:

 -Increasing system complexity As new software engineering techniques help us to build larger, more complex systems, the demands change. Systems have to be built and delivered more quickly; larger, even more complex systems are required; and systems have to have new capabilities that were previously thought to be impossible. New software engineering techniques have to be developed to meet new the challenges of delivering more complex software.
 
 -Failure to use software engineering methods It is fairly easy to write computer programs without using software engineering methods and techniques. Many companies have drifted into software development as their products and services have evolved. They do not use software engineering methods in their everyday work. Consequently, their software is often more expensive and less reliable than it should be. We need better software engineering education and training to address this problem.
 
-Software engineers have every right to be pleased with their accomplishments. Developing complicated software is still a challenge for us, yet without software engineering, we would not have developed the Internet or contemporary telecommunications, nor would we have explored space. It would be more costly and unsafe to go in any way. The 21st century presents several challenges for humanity, including climate change, a shortage of natural resources, shifting demographics, and an increasing global population. To create the systems we require to address these concerns, we will rely on software engineering.





## 2.0 Software Engineering

### Key Elements of Software Engineering
Software engineering is the process of designing and building software systems using principles from other disciplines, such as management science and computer science. Despite having a sizable common area of concern, education in software engineering is fundamentally distinct from education in computer science, management science, or other constituent subjects. It is imperative that we define concepts, not merely haphazard collections of techniques, on which to build integrated software engineering programs. We suggest that computer science, management science, communication skills, problem solving, and design methodology should be included in any software engineering curriculum. This is based on our research, teaching, and real-world experience.

### Applicable Software Engineering Methodologies
When implementing new features, teams employ the agile development technique to reduce risk. Teams create software in iterations that include tiny increments of new functionality according to all agile development methodologies. The agile development methodology comes in a variety of forms, including as scrum, crystal, extreme programming (XP), and feature-driven development.

![3-SoftwareProcesses](https://user-images.githubusercontent.com/79364739/216875404-5d30fce3-794b-4857-99b3-d2409e07a85c.jpg)

### The Fundamentals of Software Engineering
A software process, sometimes referred to as a software methodology, is a collection of related tasks that result in the creation of software. These tasks could include creating new software from scratch or altering an existing one. The following four actions must be included in any software process:
Software specifications define the primary software functionality and the restrictions that apply to them in the software specification (also known as requirements engineering). Software design and implementation is Programming and design of the software are required. Software validation the software must adhere to its specification and satisfy the needs of the user. Software evolution is the software being updated to reflect changes in customer and market demands. In actuality, they comprise sub-activities like unit testing, architectural design, and requirements validation.
The waterfall method separates the process activities of requirements specification, software design, development, validation, and testing into separate process phases. The strategy known as the incremental development method interleaves the processes of specification, development, and validation. The system is created in a series of versions, each of which includes functionality that was not present in the prior iteration. The procedure that depends on the availability of reusable systems or components is integration and configuration. The system development process focuses on setting up and integrating this component for use in a new environment.

### Software Process Models
The process of gathering stakeholder wants and wishes and turning them into an accepted set of specific requirements that can be the foundation for all ensuing development operations is known as requirements engineering. Making the problem that is being expressed clear and comprehensive and ensuring that the solution is accurate, reasonable, and efficient are the two goals of requirements engineering approaches. This chapter lists the representative requirements engineering approaches that are currently in use, mostly concentrating on the fundamentals. Requirements engineering techniques are methods for transforming real-world issues into solutions for the digital world. Each approach uses a distinct process to develop the system specification as the solution, each with its own specialized way of thinking about the real-world problem.





## 3.0 Software Development and Requirements Engineering

### Scrum, Agile Development Techniques and Scaling
A team completes a predetermined amount of work during a timed period called a Scrum sprint cycle. Each sprint begins as soon as the previous one is over and lasts for two to four weeks on average. The Scrum sprint cycle is frequently described as a continuous development method.

It gives product releases a predictable work cadence and maintains the project's momentum till completion which leads to extreme programming. Extreme Programming (XP) is an agile software development paradigm that seeks to deliver software of a better caliber while also improving the team's quality of life. Of the agile frameworks, XP is the most explicit in terms of the proper engineering techniques for software development.

For small and medium sized projects that can be developed by a small co-located team, agile methodologies have shown to be effective. It is occasionally asserted that the effectiveness of these techniques is due to enhanced communication, which is achievable when everyone is cooperating. Agile methodologies need to be modified in order to handle bigger, lengthier projects with various development teams that may be spread out across different regions.

### User and System Requirements
Users and system needs are not that different from one another. User requirements specify what the user is expected to do. System requirements include both functional needs such as the system should manage 100000 users at the same time and non-functional requirements that specify how the user will fulfill user requirements when engaging with the system.

User Requirements: The user's test results must be visible to them.
System Requirements: The user accesses the results page to view their test results as per the system requirement.

![4-RequirementsEngineering](https://user-images.githubusercontent.com/79364739/216875618-2a9580d8-7b76-442a-ad4e-9cc30958e92c.jpg)

### Functional and Non-Functional Requirements
Functional requirements These include expectations for the system's functionality, its responses to different inputs, and how it would need to respond in certain circumstances. The functional requirements may, in some situations, also explicitly indicate what the system should not accomplish. Requirements that are not functional These are limitations on the products or services the system has to offer. They include limitations imposed by standards, deadline restrictions, and limitations on the development process. Non-functional requirements frequently concern the entire system rather than specific features or services.

### Main Activities for Requirements Engineering
   -Elucidating Requirements
   Understanding what stakeholders do and how they could utilize a new system to support that work is the goal of the software requirements elicitation process. Software engineers collaborate with stakeholders during requirements elicitation to learn about the application domain, work activities, services, and system features that stakeholders desire, as well as the necessary system performance. hardware limitations, etc.
   
   -Specifying Requirements
   Writing down the user and system needs in a requirements document is the process known as requirements specification. The requirements for the user and the system should be distinct, straightforward, simple to comprehend, comprehensive, and consistent.
   
   -Validating Requirements
   Writing down the user and system needs in a requirements document is the process known as requirements specification. The requirements for the user and the system should be distinct, straightforward, simple to comprehend, comprehensive, and consistent.
   
   -Requirements Always Change
   New requirements always appear once a system has been implemented and is being utilized frequently. This is partially due to mistakes and omissions in the initial specifications that must be fixed. However, changes to the system's business environment are the main driver of changes in system requirements.





## 4.0 System Modeling and Architectural Design

### Differences Between Applying Different System Models
Essential viewpoints in software engineering and systems design include context, interaction, structure, and behavior modeling. To comprehend and create complex systems, various models are used since each one offers a unique perspective on the system under development. Interaction modeling focuses on how components interact with one another, structure modeling offers a thorough perspective of the components, and behavior modeling captures the system's changing behavior over time. Context modeling offers a high-level view of the system's surroundings.

Context modeling offers a broad perspective of the environment surrounding the system, including outside variables that affect the system's behavior. The focus of interaction modeling is on the relationships and interactions that exist between the various system components. Structure modeling offers a thorough perspective of the system's elements, including a look at their internal organization and interrelationships. Behavior modeling offers a dynamic perspective of the system, capturing how the parts work together and behave over time in response to alterations in the outside world or the actions of other parts.

### The Model View Controller

![5-SystemModeling](https://user-images.githubusercontent.com/79364739/216875939-eab9b5f1-d1aa-485b-a12e-175c982dda5a.jpg)

### 5 Unified Modeling Languages
Software engineers utilize the Model-View-Controller (MVC) design pattern to separate the presentation of information from how the user interacts with it. There are three primary parts to the pattern:

Model: Represents the application's core data and business logic. The Business Logic Layer or the Data Access Layer would normally be the counterpart of the Model component in a layered architecture.

View: Gives the viewer a visual representation of the data. The View component would normally match the Presentation Layer in a layered architecture. The View component would normally be built on the client side in a Client-Server architecture.

Controller: As a bridge between the Model and the View, the Controller manages user input and coordinates updates to both the Model and the View. Layered Architecture is a type of

By preventing changes to one component from affecting the other components, the MVC pattern's separation of responsibilities enhances the application's maintainability, scalability, and testability. Both the View and the Controller can be updated independently of the Model component, and the Model and Controller can be updated independently of the View.

In a web-based application, for instance, the Model component might stand in for a database of products and the information related to them, the View component might represent the user interface through which the user is shown the product information, and the Controller component might manage user input, such as adding or removing products from the database.

![6-ArchitecturalDesign](https://user-images.githubusercontent.com/79364739/216875947-9fa0e3a4-df44-45ec-ae19-4f08626f5003.jpg)

### Behavioral Modeling
A method for describing how a system behaves in response to events is called behavioral modeling. While event-driven modeling concentrates on the occurrences that cause changes in the state of the system, data-driven modeling concentrates on the data that drives the behavior of the system. Both modeling approaches can be used to explain how a system behaves and, depending on the needs of the system, are suitable in certain situations. Data-driven modeling and event-driven modeling are the two basic categories of behavioral modeling (state diagram).

Data-driven modeling: In data-driven modeling, the values of the system's inputs and internal data influence how the system behaves. The model specifies a set of interactions between the system's inputs and outputs, and by resolving these relationships, the system's behavior is ascertained. The information that underlies the system's action is the focus.
Event-driven modeling (state diagram): In event-driven modeling, the occurrence of events controls the system's behavior. The model outlines the possible states for the system, as well as potential events and the resulting transitions between states. The emphasis is on the occurrences that cause changes in the system's state.

### Generic Models of Application Systems
An application system known as a transaction processing system (TPS) processes transactions, the fundamental units of work that cause a change in the state of the system. TPSs are built to ensure the integrity of the data being processed while handling massive quantities of data and numerous transactions quickly.

Language Processing System (LPS): An application system that processes and modifies language data is known as an LPS. An LPS's primary objective is to transform one language into a different way of presenting that language, such as through transcribing spoken language into writing or translating a document from one language to another.





## 5.0 Software Design, Implementation, and Testing

### Software Reuse

### The Fundamental Configuration Management Activities

### Host-Target Development Platform

![7-DesignAndImplementation](https://user-images.githubusercontent.com/79364739/216876005-f0472e41-fe57-4561-a7ad-f0a3db1db769.jpg)

### Open-Source Development

### Software Inspection

### Development and User Testing

![8-SoftwareTesting](https://user-images.githubusercontent.com/79364739/216876014-00ae4fa1-70cf-45dd-b258-b664ce0c955d.jpg)

### Software Design, Implementation, and Testing Concept Maps





## 6.0 Software Evolution and Maintenance

### Four Clusters of N Systems

### Types of Software Maintenance

![9-SoftwareEvolution](https://user-images.githubusercontent.com/79364739/216876107-675874ed-e6d9-405a-9e14-b15aee81a9f8.jpg)

### Reengineering of the Software Process

### Software Evolution

### Software Evolution Concept Map
