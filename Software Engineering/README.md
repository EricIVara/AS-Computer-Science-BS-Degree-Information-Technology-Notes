# Software Engineering

## Table of Contents

   - [Introduction](#introduction)
   - [Software Engineering](#Software-Engineering)
      - [Key Elements of Software Engineering](#Key-Elements-of-Software-Engineering)
      - [Applicable Software Engineering Methodologies](#Applicable-Software-Engineering-Methodologies)
      - [The Fundamentals of Software Engineering](#The-Fundamentals-of-Software-Engineering)
      - [Software Process Models](#Software-Process-Models)
      - [Software Development Life Cycle Concept Map](#Software-Development-Life-Cycle-Concept-Map)
   - [Software Development and Requirements Engineering](#Software-Development-and-Requirements-Engineering)
      - [Scrum, Agile Development Techniques and Scaling](#Scrum,-Agile-Development-Techniques-and-Scaling)
      - [User and System Requirements](#User-and-System-Requirements)
      - [Functional and Non-Functional Requirements](#Functional-and-Non-Functional-Requirements)
      - [Main Activities for Requirements Engineering](#Main-Activities-for-Requirements-Engineering)
      - [Software Development Life Cycle and Requirements Engineering Concept Map](#Software-Development-Life-Cycle-and-Requirements-Engineering-Concept-Map)

## Introduction
Government, society, and domestic and foreign enterprises and organizations all depend on software engineering to function. The modern world cannot function without software. Most electrical items include a computer and controlling software, and computer-based systems are used to manage national infrastructure and utilities. Both the financial system and industrial manufacture and distribution are fully automated. Software is used extensively in the entertainment sector, which includes the music business, video games, and film and television. By 2016, practically all software-controlled mobile phones will be Internet-capable, with more than 75% of the world's population having one.

Software systems are ethereal and abstract. They are not limited by the characteristics of the materials, nor are they controlled by physical principles or production procedures. Since software's potential has no inherent boundaries, this makes software engineering simpler. However, due to the lack of physical limitations, software systems can easily grow to be very complicated, challenging to comprehend, and expensive to modify.

Software systems come in a broad variety of forms, from straightforward embedded systems to intricate global information systems. Because various software types require various methodologies, there are no standard notations, procedures, or strategies for software engineering. Creating a controller for a scientific instrument is absolutely unrelated to creating an organizational information system. Both of these systems have little in common with a graphically complex video game. Even while not all of these applications use the same software engineering methodologies and processes, they still require software engineering.

Software disasters and failed software initiatives continue to be widely reported. Modern software development is criticized as not being suited for software engineering. However, in my opinion, two reasons are to blame for a large number of these alleged software failures:

 -Increasing system complexity As new software engineering techniques help us to build larger, more complex systems, the demands change. Systems have to be built and delivered more quickly; larger, even more complex systems are required; and systems have to have new capabilities that were previously thought to be impossible. New software engineering techniques have to be developed to meet new the challenges of delivering more complex software.
 
 -Failure to use software engineering methods It is fairly easy to write computer programs without using software engineering methods and techniques. Many companies have drifted into software development as their products and services have evolved. They do not use software engineering methods in their everyday work. Consequently, their software is often more expensive and less reliable than it should be. We need better software engineering education and training to address this problem.
 
-Software engineers have every right to be pleased with their accomplishments. Developing complicated software is still a challenge for us, yet without software engineering, we would not have developed the Internet or contemporary telecommunications, nor would we have explored space. It would be more costly and unsafe to go in any way. The 21st century presents several challenges for humanity, including climate change, a shortage of natural resources, shifting demographics, and an increasing global population. To create the systems we require to address these concerns, we will rely on software engineering.

## Software Engineering
### Key Elements of Software Engineering
Software engineering is the process of designing and building software systems using principles from other disciplines, such as management science and computer science. Despite having a sizable common area of concern, education in software engineering is fundamentally distinct from education in computer science, management science, or other constituent subjects. It is imperative that we define concepts, not merely haphazard collections of techniques, on which to build integrated software engineering programs. We suggest that computer science, management science, communication skills, problem solving, and design methodology should be included in any software engineering curriculum. This is based on our research, teaching, and real-world experience.

### Applicable Software Engineering Methodologies
When implementing new features, teams employ the agile development technique to reduce risk. Teams create software in iterations that include tiny increments of new functionality according to all agile development methodologies. The agile development methodology comes in a variety of forms, including as scrum, crystal, extreme programming (XP), and feature-driven development.

### The Fundamentals of Software Engineering
A software process, sometimes referred to as a software methodology, is a collection of related tasks that result in the creation of software. These tasks could include creating new software from scratch or altering an existing one. The following four actions must be included in any software process:
Software specifications define the primary software functionality and the restrictions that apply to them in the software specification (also known as requirements engineering). Software design and implementation is Programming and design of the software are required. Software validation the software must adhere to its specification and satisfy the needs of the user. Software evolution is the software being updated to reflect changes in customer and market demands. In actuality, they comprise sub-activities like unit testing, architectural design, and requirements validation.
The waterfall method separates the process activities of requirements specification, software design, development, validation, and testing into separate process phases. The strategy known as the incremental development method interleaves the processes of specification, development, and validation. The system is created in a series of versions, each of which includes functionality that was not present in the prior iteration. The procedure that depends on the availability of reusable systems or components is integration and configuration. The system development process focuses on setting up and integrating this component for use in a new environment.

### Software Process Models
The process of gathering stakeholder wants and wishes and turning them into an accepted set of specific requirements that can be the foundation for all ensuing development operations is known as requirements engineering. Making the problem that is being expressed clear and comprehensive and ensuring that the solution is accurate, reasonable, and efficient are the two goals of requirements engineering approaches. This chapter lists the representative requirements engineering approaches that are currently in use, mostly concentrating on the fundamentals. Requirements engineering techniques are methods for transforming real-world issues into solutions for the digital world. Each approach uses a distinct process to develop the system specification as the solution, each with its own specialized way of thinking about the real-world problem.

### Software Development Life Cycle Concept Map
![sdlc](https://user-images.githubusercontent.com/79364739/212735072-ed1be2fa-dcc3-4385-8d22-514b2eb488c8.jpg)

## Software Development and Requirements Engineering
### Scrum, Agile Development Techniques and Scaling
A team completes a predetermined amount of work during a timed period called a Scrum sprint cycle. Each sprint begins as soon as the previous one is over and lasts for two to four weeks on average. The Scrum sprint cycle is frequently described as a continuous development method.

It gives product releases a predictable work cadence and maintains the project's momentum till completion which leads to extreme programming. Extreme Programming (XP) is an agile software development paradigm that seeks to deliver software of a better caliber while also improving the team's quality of life. Of the agile frameworks, XP is the most explicit in terms of the proper engineering techniques for software development.

For small and medium sized projects that can be developed by a small co-located team, agile methodologies have shown to be effective. It is occasionally asserted that the effectiveness of these techniques is due to enhanced communication, which is achievable when everyone is cooperating. Agile methodologies need to be modified in order to handle bigger, lengthier projects with various development teams that may be spread out across different regions.

### User and System Requirements
Users and system needs are not that different from one another. User requirements specify what the user is expected to do. System requirements include both functional needs such as the system should manage 100000 users at the same time and non-functional requirements that specify how the user will fulfill user requirements when engaging with the system.

User Requirements: The user's test results must be visible to them.
System Requirements: The user accesses the results page to view their test results as per the system requirement.

### Functional and Non-Functional Requirements
Functional requirements These include expectations for the system's functionality, its responses to different inputs, and how it would need to respond in certain circumstances. The functional requirements may, in some situations, also explicitly indicate what the system should not accomplish. Requirements that are not functional These are limitations on the products or services the system has to offer. They include limitations imposed by standards, deadline restrictions, and limitations on the development process. Non-functional requirements frequently concern the entire system rather than specific features or services.

### Main Activities for Requirements Engineering
   -Elucidating Requirements
   Understanding what stakeholders do and how they could utilize a new system to support that work is the goal of the software requirements elicitation process. Software engineers collaborate with stakeholders during requirements elicitation to learn about the application domain, work activities, services, and system features that stakeholders desire, as well as the necessary system performance. hardware limitations, etc.
   
   -Specifying Requirements
   Writing down the user and system needs in a requirements document is the process known as requirements specification. The requirements for the user and the system should be distinct, straightforward, simple to comprehend, comprehensive, and consistent.
   
   -Validating Requirements
   Writing down the user and system needs in a requirements document is the process known as requirements specification. The requirements for the user and the system should be distinct, straightforward, simple to comprehend, comprehensive, and consistent.
   
   -Requirements Always Change
   New requirements always appear once a system has been implemented and is being utilized frequently. This is partially due to mistakes and omissions in the initial specifications that must be fixed. However, changes to the system's business environment are the main driver of changes in system requirements.

### Software Development Life Cycle and Requirements Engineering Concept Map
![requirements](https://user-images.githubusercontent.com/79364739/213824457-6c711333-97b8-4b18-89ec-c0a9a2890e60.jpg)
